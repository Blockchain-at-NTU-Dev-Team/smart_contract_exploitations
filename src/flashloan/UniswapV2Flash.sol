// SPDX-License-Identifier: MIT
pragma solidity ^0.8.13;

import "./Interfaces.sol";

// Official guide: https://docs.uniswap.org/contracts/v2/guides/smart-contract-integration/using-flash-swaps
contract UniswapV2FlashSwap is IUniswapV2Callee {
  address private constant UNISWAP_V2_FACTORY = 0x5C69bEe701ef814a2B6a3EDD4B1652CB9cc5aA6f;
  IUniswapV2Factory private constant factory = IUniswapV2Factory(UNISWAP_V2_FACTORY);

  IERC20 private immutable token0;
  IERC20 private immutable token1;
  IUniswapV2Pair private immutable pair;

  constructor(address _token0, address _token1) {
    token0 = IERC20(_token0);
    token1 = IERC20(_token1);
    pair = IUniswapV2Pair(factory.getPair(_token0, _token1));
  }

  function flashSwap(uint256 token1Amount) external {
    // Need to pass some data to trigger uniswapV2Call
    bytes memory data = abi.encode(msg.sender);
    // amount0Out is token0, amount1Out is token1
    pair.swap(0, token1Amount, address(this), data);
  }

  // This function is called by the token0/token1 pair contract
  function uniswapV2Call(
    address sender,
    uint256, /* amount0 */
    uint256 amount1,
    bytes calldata data
  ) external {
    require(msg.sender == address(pair), "not pair");
    require(sender == address(this), "not sender");

    address caller = abi.decode(data, (address));

    // NOTE: .997 is use officially by Uniswap V2: https://docs.uniswap.org/contracts/v2/guides/smart-contract-integration/using-flash-swaps#single-token
    uint256 repaidAmount = (amount1 * 1000) / 997 + 1; // repaidAmount * 0.997 >= borrowAmount
    uint256 fee = repaidAmount - amount1;

    // Transfer flash swap fee from caller
    token1.transferFrom(caller, address(this), fee);

    // Repay
    token1.transfer(address(pair), repaidAmount);
  }
}
