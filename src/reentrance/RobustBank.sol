// SPDX-License-Identifier: MIT

pragma solidity ^0.8.13;

import "@openzeppelin/contracts/access/Ownable.sol";
import "@openzeppelin/contracts/utils/Address.sol";

contract Escrow is Ownable {
    using Address for address payable;

    event Deposited(address indexed payee, uint256 weiAmount);
    event Withdrawn(address indexed payee, uint256 weiAmount);

    mapping(address => uint256) private _deposits;

    function depositsOf(address payee) public view returns (uint256) {
        return _deposits[payee];
    }

    function deposit(address payee) public payable virtual onlyOwner {
        uint256 amount = msg.value;
        _deposits[payee] += amount;
        emit Deposited(payee, amount);
    }

    function withdraw(address payable payee) public virtual onlyOwner {
        uint256 payment = _deposits[payee];
        _deposits[payee] = 0;
        payee.sendValue(payment);
        emit Withdrawn(payee, payment);
    }
}

abstract contract PullPayment {
  Escrow private immutable _escrow;

  constructor() {
    _escrow = new Escrow();
  }

  function withdrawPayments(address payable payee) public virtual {
    _escrow.withdraw(payee);
  }

  function payments(address dest) public view returns (uint256) {
    return _escrow.depositsOf(dest);
  }

  function _asyncTransfer(address dest, uint256 amount) internal virtual {
    _escrow.deposit{ value: amount }(dest);
  }
}

abstract contract ReentrancyGuard {
  uint256 private constant _NOT_ENTERED = 1;
  uint256 private constant _ENTERED = 2;

  uint256 private _status;

  modifier nonReentrant() {
    _nonReentrantBefore();
    _;
    _nonReentrantAfter();
  }

  function _nonReentrantBefore() private {
    require(_status != _ENTERED, "ReentrancyGuard: reentrant call");
    _status = _ENTERED;
  }

  function _nonReentrantAfter() private {
    _status = _NOT_ENTERED;
  }

  constructor() {
    _status = _NOT_ENTERED;
  }

  function _reentrancyGuardEntered() internal view returns (bool) {
    return _status == _ENTERED;
  }
}

contract ReentranceBank is ReentrancyGuard {
  mapping(address => uint256) public balances;

  function deposit() public payable {
    balances[msg.sender] = balances[msg.sender] + msg.value;
  }

  function balanceOf(address _who) public view returns (uint256) {
    return balances[_who];
  }

  function withdraw(uint256 _amount) public nonReentrant {
    if (balances[msg.sender] >= _amount) {
      (bool result, ) = msg.sender.call{ value: _amount }("");
      require(result, "withdrawal false");
      unchecked {
        balances[msg.sender] -= _amount; // unchecked to prevent underflow errors
      }
    }
  }

  receive() external payable {}
}
