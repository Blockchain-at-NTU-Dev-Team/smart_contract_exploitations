// SPDX-License-Identifier: MIT
pragma solidity ^0.8.13;

import "@openzeppelin/contracts/access/Ownable.sol";
import "@openzeppelin/contracts/utils/Strings.sol";

interface akuNFT {
  function airdropProgress() external view returns (uint256);
}

contract AkuAuction is Ownable {
  using Strings for uint256;

  address payable immutable project;

  uint256 public maxNFTs = 15000;
  uint256 public totalForAuction = 5495; //529 + 2527 + 6449

  struct bids {
    address bidder;
    uint80 price;
    uint8 bidsPlaced;
    uint8 finalProcess; //0: Not processed, 1: refunded, 2: withdrawn
  }

  uint256 private constant DURATION = 126 minutes;
  uint256 public immutable startingPrice;
  uint256 public immutable startAt;
  uint256 public expiresAt;
  uint256 public immutable discountRate;
  mapping(address => uint256) public mintPassOwner;
  uint256 public constant mintPassDiscount = 0.5 ether;
  mapping(address => uint256) public personalBids;
  mapping(uint256 => bids) public allBids;
  uint256 public bidIndex = 1;
  uint256 public totalBids;
  uint256 public totalBidValue;
  uint256 public maxBids = 3;
  uint256 public refundProgress = 1;

  akuNFT public akuNFTs;

  constructor(
    address _project,
    uint256 startingTime,
    uint256 _startingPrice,
    uint256 _discountRate
  ) {
    project = payable(_project);

    startingPrice = _startingPrice;
    startAt = startingTime;
    expiresAt = startAt + DURATION;
    discountRate = _discountRate;

    require(_startingPrice >= _discountRate * (DURATION / 6 minutes), "Starting price less than minimum");
  }

  function getPrice() public view returns (uint80) {
    uint256 currentTime = block.timestamp;
    if (currentTime > expiresAt) currentTime = expiresAt;
    uint256 timeElapsed = (currentTime - startAt) / 6 minutes;
    uint256 discount = discountRate * timeElapsed;
    return uint80(startingPrice - discount);
  }

  function bid(uint8 amount) external payable {
    _bid(amount, msg.value);
  }

  receive() external payable {
    revert("Please use the bid function");
  }

  function _bid(uint8 amount, uint256 value) internal {
    require(block.timestamp > startAt, "Auction not started yet");
    require(block.timestamp < expiresAt, "Auction expired");
    uint80 price = getPrice();
    uint256 totalPrice = price * amount;
    if (value < totalPrice) {
      revert("Bid not high enough");
    }

    uint256 myBidIndex = personalBids[msg.sender];
    bids memory myBids;
    uint256 refund;

    if (myBidIndex > 0) {
      myBids = allBids[myBidIndex];
      refund = myBids.bidsPlaced * (myBids.price - price);
    }
    uint256 _totalBids = totalBids + amount;
    myBids.bidsPlaced += amount;

    if (myBids.bidsPlaced > maxBids) {
      revert("Bidding limits exceeded");
    }

    if (_totalBids > totalForAuction) {
      revert("Auction Full");
    } else if (_totalBids == totalForAuction) {
      expiresAt = block.timestamp; //Auction filled
    }

    myBids.price = price;

    if (myBidIndex > 0) {
      allBids[myBidIndex] = myBids;
    } else {
      myBids.bidder = msg.sender;
      personalBids[msg.sender] = bidIndex;
      allBids[bidIndex] = myBids;
      bidIndex++;
    }

    totalBids = _totalBids;
    totalBidValue += totalPrice;

    // EDITOR_NOTE: Refund exceeded value
    refund += value - totalPrice;
    if (refund > 0) {
      (bool sent, ) = msg.sender.call{ value: refund }("");
      require(sent, "Failed to refund bidder");
    }
  }

  function loadMintPassOwners(address[] calldata owners, uint256[] calldata amounts) external onlyOwner {
    for (uint256 i = 0; i < owners.length; i++) {
      mintPassOwner[owners[i]] = amounts[i];
    }
  }

  function myBidCount(address user) public view returns (uint256) {
    return allBids[personalBids[user]].bidsPlaced;
  }

  function myBidData(address user) external view returns (bids memory) {
    return allBids[personalBids[user]];
  }

  function setNFTContract(address _contract) external onlyOwner {
    akuNFTs = akuNFT(_contract);
  }

  function emergencyWithdraw() external {
    require(block.timestamp > expiresAt + 3 days, "Please wait for airdrop period.");

    // EDITOR_NOTE: Vulnerable code - 01 -> Potential DoS attack
    bids memory bidData = allBids[personalBids[msg.sender]];
    require(bidData.bidsPlaced > 0, "No bids placed");
    require(bidData.finalProcess == 0, "Refund already processed");

    allBids[personalBids[msg.sender]].finalProcess = 2;
    (bool sent, ) = bidData.bidder.call{ value: bidData.price * bidData.bidsPlaced }("");
    require(sent, "Failed to refund bidder");
  }

  function processRefunds() external {
    require(block.timestamp > expiresAt, "Auction still in progress");
    uint256 _refundProgress = refundProgress;
    uint256 _bidIndex = bidIndex;
    require(_refundProgress < _bidIndex, "Refunds already processed");

    uint256 gasUsed;
    uint256 gasLeft = gasleft();
    uint256 price = getPrice();

    for (uint256 i = _refundProgress; gasUsed < 5000000 && i < _bidIndex; i++) {
      bids memory bidData = allBids[i];
      if (bidData.finalProcess == 0) {
        uint256 refund = (bidData.price - price) * bidData.bidsPlaced;
        uint256 passes = mintPassOwner[bidData.bidder];
        if (passes > 0) {
          refund += mintPassDiscount * (bidData.bidsPlaced < passes ? bidData.bidsPlaced : passes);
        }
        // EDITOR_NOTE: Vulnerable code - 01 -> Potential DoS attack
        allBids[i].finalProcess = 1;
        if (refund > 0) {
          (bool sent, ) = bidData.bidder.call{ value: refund }("");
          require(sent, "Failed to refund bidder");
        }
      }

      gasUsed += gasLeft - gasleft();
      gasLeft = gasleft();
      _refundProgress++;
    }

    refundProgress = _refundProgress;
  }

  function claimProjectFunds() external onlyOwner {
    require(block.timestamp > expiresAt, "Auction still in progress");

    // EDITOR_NOTE: Vulnerable code - 02 -> 11.5K ETH Stuck
    require(refundProgress >= totalBids, "Refunds not yet processed"); // should change refundProgress => bidIndex
    require(akuNFTs.airdropProgress() >= totalBids, "Airdrop not complete"); // should change refundProgress => bidIndex

    (bool sent, ) = project.call{ value: address(this).balance }("");
    require(sent, "Failed to withdraw");
  }

  function getAuctionDetails(address user)
    external
    view
    returns (
      uint256 remainingNFTs,
      uint256 expires,
      uint256 currentPrice,
      uint256 userBids
    )
  {
    remainingNFTs = totalForAuction - totalBids;
    expires = expiresAt;
    currentPrice = getPrice();
    if (user != address(0)) userBids = allBids[personalBids[user]].bidsPlaced;
  }
}
